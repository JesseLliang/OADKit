//
//  Created by Rene Limberger on 4/13/16.
//  Copyright Â© 2016 Favionics. All rights reserved.
//

import Foundation

// This is a formware image generator for the Ti BLE OAD firmware update process
// 
// This image is constructed with a string, this string is assumed a "fullflash" hex image
// that was read in by String(contentsOfURL: url), where url is the path to the fullflash kex image
// 
// This class parses the intel hex sting to find the start address of the image, and builds a single
// data blob from all bytes in all records in the hex file. 
//
// You can then use the nextBlock() function to get data for the next 16byte block during programming
//
// Notes: This currently only supports image type 1, app+stack and was only tested for off-chip OAD,
// using the "safe" method, where the first and last page of the flash remain intact.
// It was also only tested with fullflash intel hex files that are generated by using hexmerge.py from
// the intel hex python module, as per Ti's OAD user guide.
//
// This code was inspired by some of the OAD code in the Ti Android SensorTag app.

class FirmwareImage : NSObject {
    
    // image header
    var crc0: Int = 0
    var crc1: Int = 0
    var ver: Int = 0
    var len: Int = 0
    let uid = [UInt8](count: 4, repeatedValue: 0x45)
    var addr: UInt32 = 0
    var imgType: ImgType = .EFL_OAD_IMG_TYPE_APP
    
    // image bin blob data
    let data = NSMutableData()
    
    // fixed assumptions made, using intel hex from hexmerge.py
    let OAD_BLOCK_SIZE = 16
    let HAL_FLASH_WORD_SIZE = 4
    
    // programming counters used duing bulk block transfer
    var iBlocks = 0 // Number of blocks programmed
    var nBlocks = 0 // Total number of blocks
    
    // from: https://en.wikipedia.org/wiki/Intel_HEX
    enum RecordType: Int {
        case DATA = 0x00, EOF, EXT_SEG_ADDR, START_SEG_ADDR, EXT_LIN_ADDR, START_LIN_ADDR
    }
    
    // image types for Ti OAD target
    enum ImgType: Int {
        case EFL_OAD_IMG_TYPE_APP = 1 // TODO: support other types
    }
    
    // initialize with a string, which is a hex file read from disc
    init(file: String) {
        super.init()
        
        // trun file string into array of lines
        let lines = generateLines(file)
        
        // parse lines
        parseLines(lines)
        
        // update header fields (start address was updated during the parse)
        len = (data.length / (16 / 4))
        crc1 = Int(0xFFFF)
        crc0 = calcImageCRC(0, data: data)
        
        // reset all counters
        resetProgress()
    }
    
    // TODO: initializer that takes a file path and handles the reading as well
    //init(url: NSURL)
    
    // reset counters
    func resetProgress() {
        iBlocks = 0
        nBlocks = (len / (OAD_BLOCK_SIZE / HAL_FLASH_WORD_SIZE))
    }
    
    // request the next block in the bin blob
    func nextBlock() -> NSData? {
        let b = block(iBlocks)
        iBlocks += 1
        return b
    }
    
    // request a specific block
    private func block(blockNum: Int) -> NSData? {
        if blockNum < nBlocks {
            iBlocks = blockNum
            
            var block = [UInt8](count: OAD_BLOCK_SIZE+2, repeatedValue: 0)
            
            block[0] = (UInt8(blockNum & 0xFF))
            block[1] = (UInt8((blockNum >> 8) & 0xFF))
            
            let range = NSMakeRange(blockNum*OAD_BLOCK_SIZE, OAD_BLOCK_SIZE)
            let subdata = data.subdataWithRange(range)
            subdata.getBytes(&block[2], length: OAD_BLOCK_SIZE)
            
            return NSData(bytes: block, length: block.count)
        }
        
        return nil
    }

    // turn hex string into an array of records
    private func generateLines(string: String) -> [String] {
        let newlineChars = NSCharacterSet.newlineCharacterSet()
        return string.componentsSeparatedByCharactersInSet(newlineChars).filter{!$0.isEmpty}
    }
    
    // parse all records in the hex
    // FIXME: this is very slow. explore parsing using NSScanner, etc.
    private func parseLines(lines: [String]) {
        var currentAddressBase: UInt32 = 0
        var currentAddress: UInt32?
        
        for line in lines {
            // all lines need to start with a : character
            guard line[line.startIndex] == ":" else { continue }
            
            // try to get the number of bytes in this line
            let numBytesStr = line[line.startIndex.advancedBy(1)...line.startIndex.advancedBy(2)]
            guard let numBytes = Int(numBytesStr, radix: 16) else { continue }
            //print("numBytes:", numBytes)
            
            // try to get record type
            let recordTypeStr = line[line.startIndex.advancedBy(7)...line.startIndex.advancedBy(8)]
            guard let recordTypeInt = Int(recordTypeStr, radix: 16), recordType = RecordType(rawValue: recordTypeInt) else { continue }
            //print("\nrecordType", recordType)
            
            switch recordType {
            case .DATA:
                // try to get 16bit block address
                let blockAddrStr = line[line.startIndex.advancedBy(3)...line.startIndex.advancedBy(6)]
                guard var blockAddr = UInt32(blockAddrStr, radix: 16) else { continue }
                
                // the block address in the line is relative to a previous base address record (if there was one)
                blockAddr += currentAddressBase
                //print("blockAddr:", String(format: "0x%04x", blockAddr))
                
                // if this is the very first data block address in the image, 
                // this will be the address we report in the image header
                // the OAD target will program the image starting at this address, after reboot
                if currentAddress == nil {
                    addr = blockAddr / (16 / 4) //block address is multiple of 4 as per OAD UG
                }
                
                // this is not the first address, check if we need to padd
                if let currentAddress = currentAddress where currentAddress < blockAddr {
                    //print("gap:", String(format: "0x%04x", currentAddress), "->",String(format: "0x%04x", blockAddr))
                    let numPadBytes = Int(blockAddr-currentAddress)
                    let padData = [UInt8](count: numPadBytes, repeatedValue: 0xFF)
                    data.appendData(NSData(bytes: padData, length: padData.count))
                    //print("padded with \(numPadBytes) bytes:"/*, padData*/)
                }
                
                currentAddress = blockAddr
                
                // try to get the bytes as NsData
                let lineDataStr = line[line.startIndex.advancedBy(9)..<line.startIndex.advancedBy(9+(numBytes*2))]
                guard let lineData = lineDataStr.dataFromHexString() else { continue }
                //print("data:", lineData)
                data.appendData(lineData)
                currentAddress = currentAddress! + UInt32(lineData.length)
                
                // we only support 16 byte blocks currently
                // check that this block was 16 bytes, if not, pad 
                if lineData.length < 16 {
                    let numBytesToPad = 16-lineData.length
                    let padData = [UInt8](count: numBytesToPad, repeatedValue: 0xFF)
                    data.appendData(NSData(bytes: padData, length: padData.count))
                    currentAddress = currentAddress! + UInt32(padData.count)
                }
                
                //print("added ", lineData.length, " bytes ", String(format: "0x%04x", currentAddress!))
                
            case .EXT_LIN_ADDR:
                // try to get ext seg 16bit address
                let extLinAddrStr = line[line.startIndex.advancedBy(9)..<line.startIndex.advancedBy(9+4)]
                guard var extLinAddr = UInt32(extLinAddrStr, radix: 16) else { continue }
                extLinAddr <<= 16
                //print("extLinAddr:", String(format: "0x%04x", extLinAddr))
                // update current base address. all subsequent addresses are relative to this base address
                currentAddressBase = extLinAddr
                //print("baseAddressUpdate:", String(format: "0x%04x", currentAddressBase))
                
            case .EOF:
                break
                
            // TODO: handle the remaining record types. for Ti BLE OAD, those are not currently needed
            // because hexmerge.py doesn't produce lines of these record types
            //case .EXT_SEG_ADDR:
            //case .START_SEG_ADDR:
            //case .START_LIN_ADDR:
                
            default:
                // TODO: handle unknown record type
                ()
            }
        }
    }
    
    // print image header for debugging
    func printHdr() {
        print("FwUpdateActivity_CC26xx ", "ImgHdr.len = ", len)
        print("FwUpdateActivity_CC26xx ", "ImgHdr.ver = ", ver)
        print("FwUpdateActivity_CC26xx ", String(format: "ImgHdr.uid = 0x%02x%02x%02x%02x", uid[0], uid[1], uid[2], uid[3]));
        print("FwUpdateActivity_CC26xx ", "ImgHdr.addr = ", String(format: "0x%04x", UInt16(addr & 0xFFFF)))
        print("FwUpdateActivity_CC26xx ", "ImgHdr.imgType = ", imgType)
        print("FwUpdateActivity_CC26xx ", String(format: "ImgHdr.crc0 = 0x%04x", UInt16(crc0 & 0xFFFF)))
        print("FwUpdateActivity_CC26xx ", imgIdentifyRequestData().hexArrayString())
        //print(data)
    }
    
    // calculate CRC over the binary blob
    private func calcImageCRC(startPage: Int, data: NSData) -> Int {
        var crc = 0
        var addr = startPage * 0x1000
        
        var page = startPage
        var pageEnd = (Int)(len / (0x1000 / 4))
        let osetEnd = ((len - (pageEnd * (0x1000 / 4))) * 4)
        
        pageEnd += startPage
        
        let bytes = UnsafePointer<UInt8>(data.bytes)
        
        while (true) {
            var oset = 0
            for (oset=0; oset<0x1000; oset += 1) {
                if ((page == startPage) && (oset == 0x00)) {
                    //Skip the CRC and shadow.
                    //Note: this increments by 3 because oset is incremented by 1 in each pass
                    //through the loop
                    oset += 3
                }
                
                else if ((page == pageEnd) && (oset == osetEnd)) {
                    crc = crc16(crc, startVal: 0x00)
                    crc = crc16(crc, startVal: 0x00)
        
                    return crc
                }
                    
                else {
                    crc = crc16(crc, startVal: Int(bytes[Int(addr + oset)]))
                }
            }
        
            page += 1
            addr = page * 0x1000
        }
    }
    
    // calculate a 16bit crc
    private func crc16(startCrc: Int, startVal: Int) -> Int {
        var val = startVal
        var crc = startCrc
        let poly = 0x1021
        var cnt = 0;
        
        for (cnt = 0; cnt < 8; cnt += 1, val <<= 1) {
            var msb = 0
            
            if ((crc & 0x8000) == 0x8000) {
                msb = 1
            }
            
            else {
                msb = 0
            }
            
            crc <<= 1
            if ((val & 0x80) == 0x80) {
                crc |= 0x0001
            }
            
            if (msb == 1) {
                crc ^= poly
            }
        }
        
        return crc;
    }
    
    // generate the image header data to identify with the OAD target
    func imgIdentifyRequestData() -> NSData {
        let tmp = [
            UInt8(crc0 & 0xFF),
            UInt8((crc0 >> 8) & 0xFF),
            UInt8(crc1 & 0xFF),
            UInt8((crc1 >> 8) & 0xFF),
            UInt8(ver & 0xFF),
            UInt8((ver >> 8) & 0xFF),
            UInt8(len & 0xFF),
            UInt8((len >> 8) & 0xFF),
            uid[0],
            uid[1],
            uid[2],
            uid[3],
            UInt8(addr & 0xFF),
            UInt8((addr >> 8) & 0xFF),
            UInt8(imgType.rawValue & 0xFF),
            UInt8(0xFF)]
        
        return NSData(bytes: tmp, length: tmp.count)
    }
}

// from: http://stackoverflow.com/questions/26501276/converting-hex-string-to-nsdata-in-swift
extension NSData {
    func hexArrayString() -> String {
        var str = "["
        var bytes = [UInt8](count: length, repeatedValue: 0)
        getBytes(&bytes, length: length)
        for b in bytes {
            str += String(format: "0x%02x, ", b)
        }
        str += "]"
        return str
    }
}

extension String {
    func dataFromHexString() -> NSData? {
        let trimmedString = self.stringByTrimmingCharactersInSet(NSCharacterSet(charactersInString: "<> ")).stringByReplacingOccurrencesOfString(" ", withString: "")
        let regex = try! NSRegularExpression(pattern: "^[0-9a-f]*$", options: .CaseInsensitive)
        
        let found = regex.firstMatchInString(trimmedString, options: [], range: NSMakeRange(0, trimmedString.characters.count))
        if found == nil || found?.range.location == NSNotFound || trimmedString.characters.count % 2 != 0 {
            return nil
        }
        
        let data = NSMutableData(capacity: trimmedString.characters.count / 2)
        
        for var index = trimmedString.startIndex; index < trimmedString.endIndex; index = index.successor().successor() {
            let byteString = trimmedString.substringWithRange(Range<String.Index>(start: index, end: index.successor().successor()))
            let num = UInt8(byteString.withCString { strtoul($0, nil, 16) })
            data?.appendBytes([num] as [UInt8], length: 1)
        }
        
        return data
    }
}